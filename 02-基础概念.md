# 02 - 基础概念

## 什么是 Flutter？

Flutter 是 Google 推出的开源 UI 工具包，用于构建：
- 移动应用（iOS 和 Android）
- Web 应用
- 桌面应用（Windows、macOS、Linux）

## 核心特点

### 1. 跨平台
一套代码可以运行在多个平台上，大大提高了开发效率。

### 2. 高性能
- 使用 Dart 语言编译为原生代码
- 自绘引擎，不依赖平台原生组件
- 60fps 流畅体验

### 3. 热重载（Hot Reload）
修改代码后立即看到效果，无需重启应用。

### 4. 丰富的 Widget
提供大量预构建的 Widget，快速构建 UI。

## Dart 语言基础

Flutter 使用 Dart 语言开发。以下是 Dart 的基础语法：

### 变量声明

```dart
// 使用 var 自动推断类型
var name = 'Flutter';

// 明确指定类型
String name = 'Flutter';
int age = 25;

// 常量
final String apiKey = 'xxx';
const double pi = 3.14;
```

### 函数

```dart
// 普通函数
String greet(String name) {
  return 'Hello, $name!';
}

// 箭头函数
String greet(String name) => 'Hello, $name!';

// 可选参数
void printInfo(String name, [int? age]) {
  print('Name: $name');
  if (age != null) {
    print('Age: $age');
  }
}
```

### 类

```dart
class Person {
  String name;
  int age;
  
  Person(this.name, this.age);
  
  void introduce() {
    print('I am $name, $age years old');
  }
}
```

**重要概念**：
- **类定义** ≠ **对象创建**
- `class Person { ... }` 只是定义了类的"模板"（蓝图），不会创建实际对象
- `Person(this.name, this.age)` 是**构造函数**，定义了如何创建对象
- 要创建对象，需要调用构造函数：`Person person = Person('Alice', 25);`

**构造函数的语法**：
- `Person(this.name, this.age)` 是 Dart 的简写形式（语法糖）
- 等价于完整写法：
  ```dart
  Person(String name, int age) {
    this.name = name;
    this.age = age;
  }
  ```

**使用示例**：
```dart
// 1. 定义类（模板）
class Person {
  String name;
  int age;
  Person(this.name, this.age);
  void introduce() {
    print('I am $name, $age years old');
  }
}

// 2. 创建对象（实例化）
Person alice = Person('Alice', 25);
Person bob = Person('Bob', 30);

// 3. 使用对象
alice.introduce();  // 输出: I am Alice, 25 years old
bob.introduce();    // 输出: I am Bob, 30 years old
```

**构造函数中使用可选参数**：

```dart
// 方式 1：可选位置参数
class Person {
  String name;
  int? age;
  String? city;
  
  Person(this.name, [this.age, this.city]);
  
  void introduce() {
    print('I am $name');
    if (age != null) print('Age: $age');
    if (city != null) print('City: $city');
  }
}

// 使用
Person p1 = Person('Alice');                    // 只传 name
Person p2 = Person('Bob', 25);                  // 传 name 和 age
Person p3 = Person('Charlie', 30, 'Beijing');   // 传所有参数

// 方式 2：可选命名参数（推荐）
class Person2 {
  String name;
  int? age;
  String? city;
  
  Person2(this.name, {this.age, this.city});
  
  void introduce() {
    print('I am $name');
    if (age != null) print('Age: $age');
    if (city != null) print('City: $city');
  }
}

// 使用
Person2 p1 = Person2('Alice');                          // 只传 name
Person2 p2 = Person2('Bob', age: 25);                   // 传 name 和 age
Person2 p3 = Person2('Charlie', city: 'Beijing');      // 传 name 和 city（跳过 age）
Person2 p4 = Person2('David', age: 30, city: 'Shanghai'); // 传所有参数

```

**为什么需要花括号 `{}`？为什么不能用方括号 `[]` 按名称传递？**

**核心区别**：
- **可选位置参数 `[]`**：按**位置**识别参数（第1个、第2个...）
- **可选命名参数 `{}`**：按**名称**识别参数（`age:`, `city:`）

**可选位置参数的限制**：
```dart
void func(int a, [int? b, int? c]) { ... }

func(1, 2, 3);        // ✅ 可以：按位置传递
// func(1, c: 3);     // ❌ 错误：不能按名称传递
// func(1, , 3);      // ❌ 错误：不能跳过中间参数
```

**为什么不能？**
- 可选位置参数通过**位置**识别，编译器不知道 `c: 3` 中的 `c` 是什么
- 如果允许 `func(1, c: 3)`，编译器无法判断这是传给 `b` 还是 `c`

**可选命名参数的优势**：
```dart
void func(int a, {int? b, int? c}) { ... }

func(1);              // ✅ 可以：只传 a
func(1, b: 2);        // ✅ 可以：按名称传递
func(1, c: 3);        // ✅ 可以：跳过 b，只传 c
func(1, c: 3, b: 2);  // ✅ 可以：顺序不重要
```

**为什么可以？**
- 可选命名参数通过**名称**识别，`b: 2` 明确表示传给 `b`
- 编译器通过参数名称就能判断，所以可以跳过中间参数

**使用建议**：
- **参数少、有逻辑顺序** → 用位置参数 `[]`（如：长、宽、高）
- **参数多、需要灵活** → 用命名参数 `{}`（如：用户信息、配置项）
- **需要跳过中间参数** → 必须用命名参数 `{}`

```
// 方式 3：默认值（不需要可空类型）
class Person3 {
  String name;
  int age;
  String city;
  
  Person3(this.name, [this.age = 0, this.city = 'Unknown']);
  
  void introduce() {
    print('I am $name, $age years old, from $city');
  }
}

// 使用
Person3 p1 = Person3('Alice');                    // age=0, city='Unknown'
Person3 p2 = Person3('Bob', 25);                  // city='Unknown'
Person3 p3 = Person3('Charlie', 30, 'Beijing');  // 传所有参数
```

## Widget 系统

### 什么是 Widget？

在 Flutter 中，**一切都是 Widget**：
- 文本是 Widget
- 按钮是 Widget
- 布局是 Widget
- 甚至应用本身也是 Widget

### Widget 类型

#### 1. StatelessWidget（无状态 Widget）
不会改变状态的 Widget。

```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Text('Hello Flutter');
  }
}
```

#### 2. StatefulWidget（有状态 Widget）
可以改变状态的 Widget。

```dart
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int count = 0;
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $count'),
        ElevatedButton(
          onPressed: () {
            setState(() {
              count++;
            });
          },
          child: Text('Increment'),
        ),
      ],
    );
  }
}
```

**为什么 StatelessWidget 可以写一个类，而 StatefulWidget 需要两个类？**

**核心原因**：Flutter 的设计理念

| Widget 类型 | 类数量 | 原因 |
|------------|--------|------|
| **StatelessWidget** | 1个类 | 不需要状态，UI 不会改变，可以合并 |
| **StatefulWidget** | 2个类 | 需要分离"配置"和"状态" |

**详细解释**：

1. **Widget 是不可变的**
   - `CounterWidget` 一旦创建就不能改变
   - 如果状态改变（`count++`），Flutter 会创建新的 Widget 实例
   - Widget 只负责保存"配置"（如初始值）

2. **State 是可变的**
   - `_CounterWidgetState` 负责保存"状态"（如 `count`）
   - 状态改变时，只重建 UI，不重建 State 对象
   - State 对象可以复用，避免重复创建

3. **性能优化**
   - Widget 重建很轻量（只是配置对象）
   - State 对象保持存活，状态不会丢失
   - 如果合并成一个类，每次重建都要重新创建所有状态，性能差

**类比理解**：

- **StatelessWidget** = 一张照片（内容固定，不需要改变）
- **StatefulWidget** = 一个相框（Widget）+ 照片（State）
  - 相框本身不变（配置）
  - 照片内容可以换（状态改变）
  - 换照片时，不需要换相框（只重建 UI，不重建 State）

**简单总结**：
- 无状态：UI 不变 → 只需要一个类
- 有状态：UI 会变 → 需要两个类（Widget 存配置，State 存状态）

**多个状态变量的写法**：

```dart
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  // 在 State 类中定义多个状态变量
  int count = 0;
  int count1 = 0;
  int count2 = 0;
  
  // 修改状态的方法
  void _incrementCount() {
    setState(() {
      count++;
    });
  }
  
  void _incrementCount1() {
    setState(() {
      count1++;
    });
  }
  
  void _incrementCount2() {
    setState(() {
      count2++;
    });
  }
  
  // 也可以在一个 setState 中同时修改多个变量
  void _incrementAll() {
    setState(() {
      count++;
      count1++;
      count2++;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $count'),
        Text('Count1: $count1'),
        Text('Count2: $count2'),
        ElevatedButton(
          onPressed: _incrementCount,
          child: Text('增加 Count'),
        ),
        ElevatedButton(
          onPressed: _incrementCount1,
          child: Text('增加 Count1'),
        ),
        ElevatedButton(
          onPressed: _incrementCount2,
          child: Text('增加 Count2'),
        ),
        ElevatedButton(
          onPressed: _incrementAll,
          child: Text('全部增加'),
        ),
      ],
    );
  }
}
```

**关键点**：
- ✅ 所有状态变量都定义在 `_CounterWidgetState` 类中
- ✅ 修改状态时，在 `setState()` 中更新变量
- ✅ 可以一次修改一个变量，也可以一次修改多个变量
- ✅ 只要在 `setState()` 中修改的变量，Flutter 都会重新构建 UI

**重要：setState 的批处理机制**

```dart
void _updateAll() {
  setState(() {
    count = 10;
    count1 = 20;
    count2 = 30;
  });
  // ✅ 只会触发 1 次 UI 更新！
  // 即使修改了 3 个变量，Flutter 也只会重新构建一次 UI
}
```

**原因**：
- `setState()` 是**异步批处理**操作
- 同一个 `setState()` 中修改的所有变量，会在**同一帧**中一起更新
- Flutter 会将所有修改合并，然后**只触发一次** UI 重新构建

**对比**：

```dart
// ❌ 不推荐：多次 setState，会触发多次 UI 更新
void _updateBad() {
  setState(() {
    count = 10;
  });
  setState(() {
    count1 = 20;
  });
  setState(() {
    count2 = 30;
  });
  // 会触发 3 次 UI 更新，性能差
}

// ✅ 推荐：一次 setState，只触发一次 UI 更新
void _updateGood() {
  setState(() {
    count = 10;
    count1 = 20;
    count2 = 30;
  });
  // 只触发 1 次 UI 更新，性能好
}
```

**性能优化建议**：
- ✅ 尽量在一个 `setState()` 中修改所有相关变量
- ❌ 避免在循环或异步操作中多次调用 `setState()`
- ✅ 如果需要在不同时间修改不同变量，考虑是否需要合并到一个 `setState()`

**setState 是同步还是异步？**

这是一个容易混淆的问题！答案是：**调用是同步的，但 UI 更新是异步的**。

```dart
void _incrementCount() {
  print('1. setState 之前: $count');
  
  setState(() {
    count++;  // 这行代码是同步执行的
    print('2. setState 内部: $count');  // 立即执行
  });
  
  print('3. setState 之后: $count');  // 立即执行，值已更新
  // 但是 UI 还没有重新构建！
}

// 输出：
// 1. setState 之前: 0
// 2. setState 内部: 1  ← 同步执行
// 3. setState 之后: 1  ← 同步执行
// UI 更新会在下一帧执行（异步）
```

**详细说明**：

1. **setState() 调用本身是同步的**
   - 回调函数会立即执行
   - 状态变量立即更新
   - 所有同步代码都会立即执行

2. **UI 重新构建是异步的**
   - `build()` 方法不会立即调用
   - 会在当前帧完成后的下一帧执行
   - 这是 Flutter 的性能优化机制

3. **实际执行顺序**：
   ```dart
   setState(() {
     count++;  // 1. 同步：立即执行
   });
   print(count);  // 2. 同步：立即执行，已经是新值
   // 3. 异步：UI 会在下一帧更新
   ```

**如果需要 UI 更新后执行代码**：

```dart
void _incrementCount() {
  setState(() {
    count++;
  });
  
  // ✅ 在 UI 更新后执行
  WidgetsBinding.instance.addPostFrameCallback((_) {
    print('UI 已更新，当前 count: $count');
    // 可以安全地访问更新后的 UI
  });
}
```

**关键理解**：
- ✅ `setState()` 的回调是**同步**的
- ✅ 状态变量更新是**同步**的
- ✅ UI 重新构建是**异步**的（下一帧）
- ✅ 这是 Flutter 的批处理优化，避免不必要的 UI 重建

**Flutter vs React Native：setState 对比**

| 特性 | React Native | Flutter |
|------|-------------|---------|
| **setState 调用** | 异步 | 同步（回调立即执行） |
| **状态更新时机** | 异步（下一帧） | 同步（立即更新） |
| **UI 更新时机** | 异步 | 异步（下一帧） |
| **执行后触发动作** | 需要 useEffect/监听 | 可以直接执行 |

**React Native 中的 setState（异步）**：

```javascript
// React Native
this.setState({ count: this.state.count + 1 });
console.log(this.state.count);  // ❌ 还是旧值！因为 setState 是异步的

// 需要通过 useEffect 监听
useEffect(() => {
  console.log('Count 变化了:', count);
}, [count]);
```

**Flutter 中的 setState（同步回调，异步 UI）**：

```dart
// Flutter
setState(() {
  count++;
});
print(count);  // ✅ 已经是新值！因为回调是同步的

// 可以直接在 setState 后执行动作
setState(() {
  count++;
});
_onCountChanged();  // ✅ 可以直接调用，状态已经更新
```

**你的理解修正**：

1. ✅ **React Native 中 setState 是异步的** - 正确
2. ⚠️ **Flutter 中 setState 是同步的** - 部分正确
   - 更准确的说法：`setState()` 的**回调函数是同步执行的**
   - 但 UI 更新仍然是异步的（下一帧）
3. ⚠️ **RN 中只能通过监听状态值变化来触发动作** - 不完全准确
   - RN 也可以通过回调函数：`this.setState({ count: 1 }, () => { /* 回调 */ })`
   - 但通常使用 useEffect/useCallback 等 Hook
4. ✅ **Flutter 中可以在 setState 执行之后直接主动触发动作** - 正确

**总结对比**：

```dart
// Flutter：setState 回调同步执行
setState(() {
  count++;
});
// 这里 count 已经是新值了
doSomethingAfterStateUpdate();  // ✅ 可以直接调用

// React Native：setState 完全异步
this.setState({ count: this.state.count + 1 });
// 这里 this.state.count 还是旧值
this.doSomethingAfterStateUpdate();  // ❌ 可能还是旧值

// RN 需要通过回调
this.setState({ count: 1 }, () => {
  // ✅ 在这里执行，状态已更新
  this.doSomethingAfterStateUpdate();
});
```

**实际应用建议**：

- **Flutter**：可以直接在 `setState()` 后执行动作，因为状态已同步更新
- **React Native**：使用 `setState` 的回调参数，或使用 `useEffect` 监听状态变化

**多个状态值的管理方式**

如果有多个状态值，可以采用以下几种方式：

#### 方式 1：在一个 State 类中管理（最简单）

```dart
class _CounterWidgetState extends State<CounterWidget> {
  // 所有状态变量都在一个 State 类中
  int count = 0;
  int count1 = 0;
  int count2 = 0;
  String name = '';
  bool isActive = false;
  
  // 使用一个 setState 同时更新
  void _updateAll() {
    setState(() {
      count = 10;
      count1 = 20;
      count2 = 30;
      name = 'Flutter';
      isActive = true;
    });
  }
}
```

**优点**：简单直接，易于理解  
**缺点**：状态多时会显得臃肿

#### 方式 2：使用多个 ValueNotifier（独立监听）

```dart
class _CounterWidgetState extends State<CounterWidget> {
  // 每个状态值使用独立的 ValueNotifier
  final ValueNotifier<int> countNotifier = ValueNotifier<int>(0);
  final ValueNotifier<int> count1Notifier = ValueNotifier<int>(0);
  final ValueNotifier<String> nameNotifier = ValueNotifier<String>('');
  
  @override
  void initState() {
    super.initState();
    // 为每个状态添加独立的监听器
    countNotifier.addListener(() {
      print('Count 变化了: ${countNotifier.value}');
    });
    count1Notifier.addListener(() {
      print('Count1 变化了: ${count1Notifier.value}');
    });
  }
  
  @override
  void dispose() {
    countNotifier.dispose();
    count1Notifier.dispose();
    nameNotifier.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // 每个状态使用独立的 ValueListenableBuilder
        ValueListenableBuilder<int>(
          valueListenable: countNotifier,
          builder: (context, count, child) {
            return Text('Count: $count');
          },
        ),
        ValueListenableBuilder<int>(
          valueListenable: count1Notifier,
          builder: (context, count1, child) {
            return Text('Count1: $count1');
          },
        ),
        ElevatedButton(
          onPressed: () {
            countNotifier.value++;
          },
          child: Text('增加 Count'),
        ),
      ],
    );
  }
}
```

**优点**：每个状态可以独立监听和更新  
**缺点**：代码较多，需要管理多个监听器

#### 方式 3：创建一个状态管理类（推荐）

```dart
// 创建一个统一的状态管理类
class CounterState {
  int count = 0;
  int count1 = 0;
  int count2 = 0;
  
  // 可以添加状态变化回调
  void Function()? onStateChanged;
  
  void updateCount(int value) {
    count = value;
    onStateChanged?.call();
  }
  
  void updateCount1(int value) {
    count1 = value;
    onStateChanged?.call();
  }
  
  void updateAll({int? count, int? count1, int? count2}) {
    if (count != null) this.count = count;
    if (count1 != null) this.count1 = count1;
    if (count2 != null) this.count2 = count2;
    onStateChanged?.call();
  }
}

class _CounterWidgetState extends State<CounterWidget> {
  final CounterState _state = CounterState();
  
  @override
  void initState() {
    super.initState();
    _state.onStateChanged = () {
      setState(() {});  // 触发 UI 更新
    };
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: ${_state.count}'),
        Text('Count1: ${_state.count1}'),
        ElevatedButton(
          onPressed: () {
            _state.updateCount(_state.count + 1);
          },
          child: Text('增加 Count'),
        ),
      ],
    );
  }
}
```

**优点**：代码组织清晰，易于维护  
**缺点**：需要额外创建一个类

#### 方式 4：分离成多个 StatefulWidget（适合复杂场景）

```dart
// 每个状态值使用独立的 Widget
class CountWidget extends StatefulWidget {
  @override
  _CountWidgetState createState() => _CountWidgetState();
}

class _CountWidgetState extends State<CountWidget> {
  int count = 0;
  // ... 只管理 count 相关的状态
}

class Count1Widget extends StatefulWidget {
  @override
  _Count1WidgetState createState() => _Count1WidgetState();
}

class _Count1WidgetState extends State<Count1Widget> {
  int count1 = 0;
  // ... 只管理 count1 相关的状态
}
```

**优点**：职责分离，每个 Widget 只管理自己的状态  
**缺点**：如果状态需要共享，会比较麻烦

#### 方式 5：使用状态管理库（复杂应用推荐）

```dart
// 使用 Provider, Riverpod, GetX 等状态管理库
// 这里以 Provider 为例（需要添加依赖）

class CounterProvider extends ChangeNotifier {
  int _count = 0;
  int _count1 = 0;
  
  int get count => _count;
  int get count1 => _count1;
  
  void incrementCount() {
    _count++;
    notifyListeners();  // 通知所有监听者
  }
  
  void incrementCount1() {
    _count1++;
    notifyListeners();
  }
}
```

**优点**：专业的状态管理方案，适合大型应用  
**缺点**：需要学习状态管理库

**选择建议**：

| 场景 | 推荐方式 |
|------|---------|
| 状态少（< 5个） | 方式 1：一个 State 类管理 |
| 状态多但独立 | 方式 2：多个 ValueNotifier |
| 状态需要统一管理 | 方式 3：状态管理类 |
| 状态相互独立 | 方式 4：分离成多个 Widget |
| 大型应用 | 方式 5：状态管理库（Provider/Riverpod） |

**监听状态变化**：

当 `count` 变化时触发监听动作，有几种方式：

#### 方式 1：直接在 setState 后执行（推荐）

```dart
class _CounterWidgetState extends State<CounterWidget> {
  int count = 0;
  
  void _incrementCount() {
    setState(() {
      count++;
    });
    // setState 后立即执行监听动作
    _onCountChanged();
  }
  
  // 监听方法
  void _onCountChanged() {
    print('Count 变化了: $count');
    // 可以执行任何你需要的动作
    // 比如：保存到数据库、发送网络请求、更新其他状态等
  }
}
```

#### 方式 2：使用 addPostFrameCallback（在 UI 更新后执行）

```dart
class _CounterWidgetState extends State<CounterWidget> {
  int count = 0;
  
  void _incrementCount() {
    setState(() {
      count++;
    });
    // 在 UI 构建完成后执行
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _onCountChanged();
    });
  }
  
  void _onCountChanged() {
    print('Count 变化了: $count');
    // 在这里可以安全地访问最新的 UI 状态
  }
}
```

#### 方式 3：使用自定义 getter/setter

```dart
class _CounterWidgetState extends State<CounterWidget> {
  int _count = 0;
  
  // 使用 getter
  int get count => _count;
  
  // 使用 setter 监听变化
  set count(int value) {
    if (_count != value) {
      setState(() {
        _count = value;
      });
      _onCountChanged();
    }
  }
  
  void _incrementCount() {
    count++;  // 自动触发监听
  }
  
  void _onCountChanged() {
    print('Count 变化了: $count');
  }
}
```

#### 方式 4：使用 ValueNotifier（适合复杂场景）

```dart
class _CounterWidgetState extends State<CounterWidget> {
  final ValueNotifier<int> countNotifier = ValueNotifier<int>(0);
  
  @override
  void initState() {
    super.initState();
    // 添加监听器
    countNotifier.addListener(_onCountChanged);
  }
  
  @override
  void dispose() {
    // 移除监听器，避免内存泄漏
    countNotifier.removeListener(_onCountChanged);
    countNotifier.dispose();
    super.dispose();
  }
  
  void _incrementCount() {
    countNotifier.value++;  // 自动触发监听
  }
  
  void _onCountChanged() {
    print('Count 变化了: ${countNotifier.value}');
  }
  
  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<int>(
      valueListenable: countNotifier,
      builder: (context, count, child) {
        return Column(
          children: [
            Text('Count: $count'),
            ElevatedButton(
              onPressed: _incrementCount,
              child: Text('增加'),
            ),
          ],
        );
      },
    );
  }
}
```

**选择建议**：
- **简单场景**：使用方式 1（直接在 setState 后执行）
- **需要访问 UI 后执行**：使用方式 2（addPostFrameCallback）
- **需要自动监听**：使用方式 3（getter/setter）或方式 4（ValueNotifier）
- **复杂状态管理**：使用方式 4（ValueNotifier）或考虑使用 Provider、Riverpod 等状态管理库

## Material Design vs Cupertino

Flutter 提供两套设计风格：

- **Material Design**：Google 的设计语言，用于 Android
- **Cupertino**：Apple 的设计语言，用于 iOS

## 项目结构

```
my_app/
├── lib/
│   └── main.dart          # 应用入口
├── test/                   # 测试文件
├── pubspec.yaml           # 依赖配置
└── README.md
```

## 下一步

了解基础概念后，开始创建 [第一个应用](./03-第一个应用.md)！

