# 06 - 状态管理

## 什么是状态？

状态是 Widget 中可以在运行时改变的数据。当状态改变时，UI 需要更新以反映新的状态。

## StatefulWidget

### 基本用法

```dart
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_counter'),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Increment'),
        ),
      ],
    );
  }
}
```

### setState() 的重要性

`setState()` 告诉 Flutter 状态已改变，需要重新构建 Widget 树。

## 状态提升（Lifting State Up）

当多个 Widget 需要共享状态时，将状态提升到共同的父 Widget。

```dart
class ParentWidget extends StatefulWidget {
  @override
  _ParentWidgetState createState() => _ParentWidgetState();
}

class _ParentWidgetState extends State<ParentWidget> {
  String _sharedData = '';

  void _updateData(String newData) {
    setState(() {
      _sharedData = newData;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ChildWidget1(data: _sharedData),
        ChildWidget2(onUpdate: _updateData),
      ],
    );
  }
}
```

## 状态管理方案

### 1. setState（简单场景）

适用于：
- 单个页面的简单状态
- 不需要跨页面共享的状态

### 2. Provider（推荐）

需要添加依赖：
```yaml
dependencies:
  provider: ^6.0.0
```

使用示例：
```dart
// 定义 Model
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();
  }
}

// 提供 Provider
ChangeNotifierProvider(
  create: (_) => CounterModel(),
  child: MyApp(),
)

// 使用 Provider
Consumer<CounterModel>(
  builder: (context, counter, child) {
    return Text('Count: ${counter.count}');
  },
)
```

上面这个 `builder` 有三个参数：

- `context`：当前 Widget 的 `BuildContext`，和你平时在 `build` 方法里拿到的是同一个，用来拿主题、路由、以及通过 `Provider.of` / `context.watch` 等获取其它依赖。
- `counter`：类型是 `CounterModel`，**就是上面 `ChangeNotifierProvider(create: (_) => CounterModel())` 提供出的那个实例**。当你在 `CounterModel` 里调用 `notifyListeners()` 时，`Consumer` 会重新调用这个 `builder`，`counter` 还是同一个对象，只是里面的字段（比如 `_count`）已经更新了。
- `child`：一个可选的「静态子 Widget」，如果你在 `Consumer` 外面包了一个不会随状态变化而变化的子组件，可以通过这个参数复用，避免重复构建；目前示例里没用到，所以可以忽略。

如果你想看一个**从 `main` 函数到页面 UI 都写完整的 Provider 示例**，可以参考进阶教程：[26-Provider 状态管理详解](./26-Provider状态管理详解.md)。

### 3. Riverpod

Provider 的改进版本，更类型安全。

### 4. Bloc

使用事件和状态流管理状态，适合复杂应用。

### 5. GetX

轻量级的状态管理方案。

## 最佳实践

1. **最小化状态**：只保存必要的状态
2. **状态提升**：将状态放在最近的共同祖先
3. **不可变数据**：使用不可变数据结构
4. **选择合适的方案**：根据项目复杂度选择状态管理方案

## 下一步

学习依赖管理与项目配置，查看 [依赖管理与 pubspec.yaml](./07-依赖管理与pubspec.yaml.md)！

